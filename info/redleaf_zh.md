# 红叶：安全操作系统中的隔离与通信

Vikram Narayanan, Tianjiao Huang, David Detweiler, Dan Appel, and
Zhaofeng Li, University of California, Irvine; Gerd Zellweger, VMware Research; 
Anton Burtsev, University of California, Irvine

本文被收录于第 14 届 USENIX 操作系统设计与实现研讨会论文集设计与实现
2020年11月 4-6

对第 14 届 USENIX 操作系统设计与实现研讨会论文集设计与实现的开放访问由USENIX赞助

## 摘要

红叶（RedLeaf）是一个从零开始用 Rust 开发的新操作系统，旨在探索语言安全对操作系统组成的影响。与商业系统相比，红叶不依赖硬件地址空间进行隔离，而只依靠 Rust 语言的类型和内存安全。脱离昂贵的硬件隔离机制让我们得以探索轻量级细粒度隔离系统的设计空间。我们开发了一个新的基于语言的轻量级隔离域的抽象，它提供了一个信息隐藏和故障隔离的单元。 域能够被动态地加载并干净地终止，即一个域中的错误不会影响其他域的运行。在红叶隔离机制的基础上，我们展示了实现设备驱动程序的端到端零拷贝、故障隔离和透明恢复的可能性。为了评估红叶抽象的实用性。我们把Rv6，一个POSIX子集操作系统实现成了若干个红叶域的集合。最后，为了证明 Rust 和细粒度隔离的实用性，我们开发了 10Gbps 英特尔 ixgbe 网卡和 NVMe 固态硬盘设备驱动程序的高效版本，其性能可与最快的 DPDK 和 SPDK 相媲美。

## 1 引入

四十年前，早期的操作系统设计认为隔离内核子系统的能力是提高整个系统可靠性和安全性的关键机制[^12,32]。 遗憾的是，尽管多次尝试在内核中引入细粒度隔离，但现代系统仍然是庞大且单一（monolithic）的。一直以来，软件和硬件机制对于高性能要求的子系统隔离来说过于昂贵。多个硬件项目探索了在硬件中实现细粒度、低开销隔离机制的能力 [^84,89,90]。然而，着眼于性能，现代商品 CPU只为用户程序的粗粒度隔离提供了基本支持。同样，几十年来，能在软件层面提供细粒度隔离的安全语言对于低级的操作系统代码来说开销仍然过高。传统上，安全语言需要一个可管理的运行时，特别是垃圾回收机制来实现安全。尽管垃圾回收技术取得了许多进步，但对于每个核心每秒处理数百万个请求的系统来说，垃圾回收的开销仍然很高（在典型的设备驱动程序工作情形中，最快的垃圾回收语言比 C 语言慢 20-50%[^28]）。

几十年来，打破单一内核的设计选择仍然不切实际。因此，现代内核缺乏隔离性及其优势：简洁的模块化、信息隐藏、故障隔离、透明的子系统恢复和细粒度访问控制。

随着 Rust 的发展，隔离和性能之间的历史平衡正在发生变化。Rust 可以说是第一种在没有垃圾回收的情况下实现安全性的实用语言[^45]。Rust 将旧的线性类型 [^86] 思想与实用的语言设计相结合，通过一个受限的所有权模型来实现类型和内存安全，允许内存中的每个生存对象只有唯一一个引用。这样就可以静态跟踪对象的生命周期，并在不使用垃圾回收器的情况下将其删除。该语言的运行时开销仅限于边界检查，且在许多情况下，现代超标量无序 CPU 可以隐藏边界检查，并预测和执行不进行检查时的正确路径 [^28]。为了实现实用的非线性数据结构，Rust 提供了一小套精心挑选的基本类型，可以摆脱线性类型系统的严格限制。

Rust 作为一种开发底层系统的工具，迅速受到人们的欢迎，而传统上这些系统都是用 C 语言开发的 [4, 24, 40, 47, 50, 65]。低开销安全带来了一系列立竿见影的安全优势————预计三分之二由典型的不安全低级语言编程习语（idiom）引起的漏洞，仅通过使用安全语言就可以消除 [^20,22,67,69,77] 。

遗憾的是，最近的项目大多把 Rust 作为 C 语言的一种替换。然而，我们认为，语言安全的真正好处在于可以实现实用、轻量级、细粒度的隔离，以及一系列几十年来一直是操作系统研究重点但却无法实用的机制：故障隔离[79]、透明设备驱动恢复[78]、安全内核扩展[13,75]、基于能力的细粒度访问控制[76]等等。

红叶 [^在叶片组织中生成的锈(Rust)菌会使叶片变红] 是一个新的操作系统，旨在探索语言安全对操作系统组成的影响，特别是在内核中利用细粒度隔离的能力及其优势。红叶是用 Rust 从零开始实现的。它不依赖硬件机制进行隔离，而只使用 Rust 语言的类型和内存安全。

尽管有多个项目在探索基于语言的系统中的隔离问题 [^6,35,39,85] ，但在 Rust 中阐明隔离原则并提供实用的实现仍然具有挑战性。一般来说，安全语言会提供一些机制来控制对单个对象字段的访问（例如 Rust 中的 `pub` 访问修饰符），并保护指针，即限制对通过可见全局变量和显式传递参数可获取的程序状态的访问。通过对引用和通信渠道的控制，可以在函数和模块边界上隔离程序的状态，以确保保密性和完整性，更广泛地说，可以通过对象能力语言[^59]所探索的一系列技术来构建全面的最小权限系统。

不幸的是，仅靠内置语言机制不足以对互不信任的系统实现隔离，如依赖语言安全隔离应用程序和内核子系统的操作系统内核。为了保护整个系统的执行，内核需要一种隔离故障的机制，即提供一种终止故障或行为不端计算的方法，使系统处于干净的状态。具体来说，在子系统终止后，隔离机制应提供途径来做到：1）取消分配给子系统使用的所有资源；2）如果一个子系统分配的对象已通过通信通道传递给其他子系统，保留它；以及 3）确保今后对已终止子系统所暴露接口的所有调用都不会违反安全规定或阻塞调用者，而是返回错误信息。面对基于语言的系统所鼓励的语义丰富的接口，故障隔离是一项挑战————频繁的引用交换往往意味着单个组件的崩溃会使整个系统处于损坏状态[^85]。

从早期的单用户、单语言、单地址空间设计 [^9,14,19,25,34,55,71,80] 到堆隔离 [^6,35] 以及使用线性类型来实现堆隔离 [^39] ，多年来，在基于语言的系统中隔离计算的目标已经走过了漫长的道路。尽管如此，如今人们对基于语言的隔离原理还不甚了解。在 Sing# 中实现故障隔离的 Singularity [^39] 依靠语言和操作系统的紧密协同设计来实现隔离机制。且最近几个提出使用 Rust 实现轻量级隔离的系统，如 Netbricks [^68] 和 Splinter [^47]，都难以阐明实现隔离的原则，而只是用 Rust 已经提供的信息隐藏来代替故障隔离。类似的，最近推出的 Rust 操作系统 Tock 通过传统的硬件机制和受限的系统调用接口支持用户进程的故障隔离，但却无法为安全 Rust 实现的设备驱动程序（胶囊）提供故障隔离 [^50] 。

我们的工作是开发安全语言的故障隔离原则和机制。我们引入了一种基于语言的隔离域抽象，作为信息隐藏、加载和故障隔离的单元。为了封装域的状态并在域边界实现故障隔离，我们制定了以下原则：

- **堆隔离** 我们将堆隔离作为对所有域的约束（invariant），即各域绝不持有指向其他域私有堆的指针。堆隔离是终止和卸载崩溃域的关键，因为没有其他域持有指向崩溃域私有堆的指针，所以卸载整个私有堆是安全的。为了实现跨域通信，我们引入了一种特殊的共享堆，允许分配可在域之间交换的对象。
- **可交换类型** 为了实现堆隔离，我们引入了可交换类型的概念，即在不泄漏指向私有堆的指针的情况下，可以安全地跨域交换的类型。可交换类型允许我们静态地实现一个约束，即在共享堆上分配的对象不能有指向私有域堆的指针，但可以有指向共享堆上其他对象的引用。
- **所有权追踪** 为了取消崩溃域在共享堆上拥有的资源，我们会跟踪共享堆上所有对象的所有权。当一个对象在域之间传递时，我们会根据它是在域之间移动还是在只读访问中被借用来更新其所有权。我们依靠 Rust 的所有权规范来强制各域在跨域函数调用中传递共享对象引用时失去所有权，也就是说，Rust 会强制要求调用者域中没有被传递对象的别名。
- **接口验证** 为了提供系统的可扩展性，并允许域作者为他们实现的子系统定义自定义接口，同时保留隔离性，我们对所有跨域接口进行了验证，确保接口仅含有可交换类型的约束，从而防止它们破坏堆隔离约束。我们开发了一种接口定义语言（IDL），可静态验证跨域接口的定义并为其生成实现。
- **跨域调用代理** 我们通过代理来调用所有跨域调用————这是在所有域接口上插入的一层可信代码。代理可更新跨域传递对象的所有权，支持从崩溃的域中解除线程的执行，并在域终止后保护未来对域的调用。我们的 IDL 通过接口定义生成代理对象的实现

上述原则使我们能够以实用的方式实现故障隔离：即使面对语义丰富的接口，隔离边界也能将开销降至最低。当域崩溃时，我们会通过解绑（unwind）当前在域内执行的所有线程的执行来隔离故障，并在不影响系统其他部分的情况下取消分配域的资源。对域接口的后续调用会返回错误类型，但仍然安全，不会引发恐慌。域分配的但在崩溃前返回的所有对象都会保持存活。

为了测试这些原则，我们将红叶实现成了一个微内核操作系统，在这个系统中，一组被隔离的域实现了内核的功能：典型的内核子系统、类 POSIX 接口、设备驱动程序和用户应用程序。红叶提供了现代内核的典型功能：多核支持、内存管理、动态加载内核扩展、类 POSIX 用户进程和快速设备驱动程序。在红叶隔离机制的基础上，我们展示了以透明方式恢复崩溃设备驱动程序的可能性。我们采用了一种与影子驱动程序类似的想法 [^78]，即轻量级影子域，它作为访问设备驱动程序的中介，并在崩溃后重新启动它，重新执行其初始化协议。

为了评估红叶抽象的通用性，我们在红叶的基础上实现了 Rv6，这是一个 POSIX 子集操作系统。Rv6 遵循 UNIX V6 规范 [^53]。尽管 Rv6 是一个相对简单的内核，但它是一个很好的平台，说明了如何将基于语言的细粒度隔离思想应用于以 POSIX 接口为中心的现代内核中。最后，为了证明 Rust 和细粒度隔离带来的开销并不高昂，我们开发了高效版本的 10Gbps 英特尔 Ixgbe 网卡和 PCIe 附加固态硬盘 NVMe 驱动程序。

我们认为，将实用语言安全与所有权规范相结合，可以让我们首次以高效的方式实现操作系统研究中的许多经典理念。红叶速度快，支持内核子系统的细粒度隔离[^57,61,62,79]、故障隔离[^78,79]、实现端到端零拷贝通信[^39]、支持用户级设备驱动程序和内核旁路[^11,21,42,70]等等。

## 2 基于语言的系统隔离

在基于语言的操作系统中，对隔离的研究由来已久，这些研究通过语言安全、指针的细粒度控制和类型系统，探索执行轻量级隔离边界的取舍方法。早期的操作系统采用安全语言开发[^9,14,19,25,34,55,71,80]。这些系统使用“开放”的架构，即单用户、单语言、单地址空间的操作系统，模糊了操作系统与应用程序本身的界限[^48]。这些系统依靠语言安全来防止意外错误，但不提供子系统或用户应用程序的隔离（现代unikernel采用类似方法 [^2,37,56]）。

SPIN 是第一个提出将语言安全作为实现动态内核扩展隔离机制的 [^13]。SPIN 利用 Modula-3 指针来保证执行保密性和完整性，但由于指针是跨隔离边界交换的，因此无法提供故障隔离————一个崩溃的扩展使系统处于不一致状态。

J-Kernel [^85] 和 KaffeOS [^6] 是最早指出语言安全本身不足以确保隔离故障和终止不受信任的子系统这一问题的内核。 为了支持 Java 中对孤立域的终止，J-Kernel 提出了对跨域共享的所有对象的访问进行中转（mediate）的想法 [^85]。J-Kernel 引入了一种特殊的功能对象，它封装了在孤立子系统中共享的原始对象的接口。为了支持域终止，由崩溃域创建的所有功能都会被撤销，从而丢弃对已被垃圾回收的原始对象的引用，并通过返回异常来阻止未来的访问。J-Kernel 依靠自定义类加载器来验证跨域接口（即在运行时生成远程指定代理，而不是使用静态 IDL 编译器）。为了实现隔离，J-Kernel 采用了一种特殊的调用约定，允许通过引用传递功能引用，但要求对常规的未封装对象进行深拷贝。由于没有共享对象的所有权约束，J-Kernel 提供的故障隔离模型有一定的局限性：当创建对象的域崩溃时，对共享对象的所有引用都会被撤销，从而将故障传播到通过跨域调用获得这些对象的域中。此外，由于缺乏 "移动 "语义，（即当对象被传递给被调用者时，调用者失去对该对象的访问权限），这意味着隔离需要对对象进行深拷贝，而这对于隔离现代高吞吐量设备驱动程序来说是非常困难的。

KaffeOS 不通过功能引用来中转对共享对象的访问，而是采用了 "写屏障"[^88] 技术，这种技术会验证整个系统中的所有指针赋值，因此可以强制执行特定的指针规范[^6]。KaffeOS 引入了私有域和特殊共享堆的分离，用于跨域共享对象————显式分离对于执行写屏障检查至关重要（如检查指针是否属于特定堆）。写入障碍用于执行以下约束：1）允许私有堆上的对象拥有指向共享堆上对象的指针，但是 2）共享堆上的对象被限制在同一个共享堆上。在跨域调用中，当共享对象的引用被传递到另一个域时，写入屏障被用来验证约束，并创建一对特殊的对象，负责共享对象的引用计数和垃圾回收。KaffeOS 有以下故障隔离模型：当对象的创建者终止时，其他域保留对该对象的访问权（引用计数确保最终对象在所有共享者终止时被回收）。遗憾的是，虽然其他域能够在对象创建者崩溃后访问这些对象，但这并不足以实现完全隔离————共享对象有可能处于不一致的状态（例如，如果对象更新到一半时发生崩溃），从而可能导致其他域停止或崩溃。与 J-Kernel 类似，隔离对象也需要在跨域调用时进行深拷贝。最后，中转所有指针更新的性能开销很大。

奇点操作系统引入了一种新的故障隔离模型，该模型是围绕静态执行的所有权规范建立的[^39]。与 KaffeOS 类似，在奇点中，应用程序使用了隔离的私有堆和用于共享对象的特殊“交换堆”。一个开创性的设计是对交换堆上分配的对象强制执行单一所有权，即同一时间只能有一个域对共享堆上的对象进行引用。在跨域传递对象引用时，对象的所有权会在域之间 "移动"（将对象传递到另一个域后，试图访问该对象会被编译器拒绝）。奇点开发了一系列新颖的静态分析和验证技术，在有垃回收圾的 Sing# 语言中静态地确保这一属性。单一所有权是实现简洁实用的故障隔离模型的关键————崩溃的域无法影响系统的其他部分————不仅它们的私有堆被隔离，而且新的所有权规范还允许隔离共享堆，即崩溃的域无法触发其他域中共享引用的撤销，也无法让共享对象处于不一致的状态中。此外，单一所有权允许以零拷贝的方式实现安全隔离，即移动语义保证了对象的发送者将失去对该对象的访问权，因此允许接收者在知道发送者无法访问新状态或改变旧状态的情况下更新对象的状态。

在 J-Kernel、KaffeOS 和奇点的启示基础上，我们的工作制定了在安全语言中执行故障隔离的原则，这些原则可以确保所有权系统。与 J-Kernel 类似，我们采用了用代理封装接口的方法。不过，我们通过静态方式生成代理，以避免运行时开销。我们依赖与 KaffeOS 和奇点类似的堆隔离。我们采用堆隔离的主要原因是，可以在不了解堆内对象语义的情况下，回收域的私有堆。我们为共享堆上的对象借用了移动语义，以提供干净的故障隔离，同时支持来自奇点的零拷贝通信。不过，我们将其扩展为只读借用语义，以支持透明域恢复，同时不放弃零拷贝。 由于红叶使用 Rust 实现，因此得益于其所有权规范，我们可以对共享堆上的对象执行移动语义。Rust 基于对线性类型[^86]、仿射类型、别名类型[^18,87]和基于区域的内存管理[^81]的大量研究，并受到 Sing# [^29]、Vault [^30] 和 Cyclone [^43]等语言的影响，在不影响语言可用性的前提下，静态地实现了所有权。与严重依赖于共同设计 Sing# [^29] 及其通信机制的奇点不同，我们在 Rust 语言之外开发了红叶的隔离抽象--可交换类型、接口验证和跨域调用代理。这样，我们就能清楚地阐明提供故障隔离所需的最基本原则，并开发出一套独立于语言之外的机制来实现这些原则，可以说，这样就能使这些原则适应特定的设计取舍。最后，我们针对系统的实用性做出了几项设计取舍。我们针对最常见的“迁移线程”模型[^31]而非消息[^39]设计并实施了隔离机制，以避免在关键的跨域调用路径上出现线程上下文切换，并允许使用更自然的编程习语，例如，在红叶中，域接口只是 Rust trait。

## 3 红叶架构

红叶采用微内核系统结构，依靠基于语言的轻量级域实现隔离（[图 1]()）。微内核实现了启动执行线程、内存管理、域加载、调度和中断转发所需的功能。隔离域集合实现了设备驱动程序、操作系统个性（即 POSIX 接口）和用户应用程序（[第 4.5 节]()）。 由于红叶不依赖硬件隔离原语，因此所有域和微内核都运行在 0 环中。 然而，域被限制使用安全的 Rust（即微内核和可信库是红叶中唯一允许使用不安全 Rust 扩展的部分）。

我们在域之间强制执行堆隔离约束。为了进行通信，域从全局共享堆中分配可共享对象，并交换指向共享堆上分配的对象的特殊指针、远程引用（`RRef<T>`）（[第 3.1 节]()）。所有权规则使我们能够实现跨隔离域的轻量级零拷贝通信（[第 3.1 节]()）

域通过正常的、类型化的 Rust 函数调用进行通信。跨域调用时，线程会在域之间移动，但会在同一堆栈上继续执行。域开发人员为域的入口点及其接口提供接口定义。红叶 IDL 编译器会自动生成创建和初始化域的代码，并检查跨域边界传递的所有类型的有效性（[第 3.1.5 节]()）。

红叶利用受信任的代理对象对所有跨域通信进行调解。代理由 IDL 编译器根据 IDL 定义自动生成（[第 3.1.5 节]()）。在每个域入口处，代理都会检查域是否存活，如果存活，则会创建一个轻量级的继续(continuation)，以便在域崩溃时解绑线程的执行。

在红叶中，对对象和trait的引用就是能力。在 Rust 中，trait声明了一个类型必须实现的一组方法，从而提供了一个接口的抽象。域通过跨域调用来交换对trait的引用，从而实现其功能。我们依靠基于功能的访问控制[^76]来执行最小特权原则，并实现灵活的操作系统组织：例如，我们实现了几种应用绕过内核直接与设备驱动程序对话的方案，甚至可以利用 DPDK 式的用户级设备驱动程序访问来链接设备驱动程序库。

**保护模型** 红叶背后的核心假设是，我们相信 (1) Rust 编译器能正确实现语言安全，以及 (2) 信任使用了不安全代码的 Rust 核心库，例如实现内部可变性的类型等。红叶的 TCB 包括微内核、实现硬件接口和底层抽象所需的少量可信红叶包、提供硬件资源安全接口的设备板块（如访问 DMA 缓冲区等）、红叶 IDL 编译器和红叶受信编译环境。目前，我们并不处理不安全 Rust 扩展中的漏洞，但我们再次推测，最终所有不安全代码都将通过功能正确性验证 [^5,8,82]。具体来说，RustBelt 项目提供了一个指南，以确保不安全代码被封装在安全接口中 [^44]。

我们相信设备是非恶意的。未来可以通过使用 IOMMU 来保护物理内存，从而放宽这一要求。最后，我们没有防范侧信道攻击；虽然这些攻击很重要，但解决它们超出了当前工作的范围。我们推测，未来的 CPU 将采用硬件对策来减少信息泄露 [^41]。

### 3.1 域和错误隔离

在红叶中，域是信息隐藏、故障隔离和组合的单元。设备驱动程序、内核子系统（如文件系统、网络栈等）和用户程序都作为域加载。每个域的参数之一是微内核系统调用接口的引用。该接口允许每个域创建执行线程、分配内存、创建同步对象等。默认情况下，微内核系统调用接口是域的唯一权限，即域可以影响系统其他部分的唯一接口。不过，域可以为入口函数定义自定义类型，要求在创建时传递对象和接口的附加引用。默认情况下，我们不会为域创建新的执行线程。

不过，每个域都可以在加载域时通过微内核调用的 `init` 函数创建线程。在内部，微内核会跟踪代表每个域创建的所有资源：分配的内存、注册的中断线程等。线程的寿命可能超过创建它们的域，因为它们会进入其他域，并在那里无限期运行。这些线程会继续运行，直到它们返回到崩溃的域，并且该域是它们延续链中的最后一个域。

**错误隔离** 红叶域支持故障隔离。我们按以下方式定义故障隔离。我们说，当进入域的线程之一出现恐慌时，域就会崩溃并需要终止。恐慌可能会使域内可访问的对象处于不一致状态，从而使域内任何线程的进一步运行变得不切实际（也就是说，即使线程没有发生死锁或恐慌，计算结果也是未定义的）。那么，如果以下条件成立，我们就可以说*故障被隔离*了。首先，我们可以将运行在崩溃域内的所有线程解绑到域入口点，并向调用者返回错误信息。其次，后续调用域的尝试会返回错误，但不会违反安全保证或导致恐慌。第三，崩溃域的所有资源都可以安全地回收，也就是说，其他域不会持有对崩溃域堆的引用（堆隔离约束），我们可以回收该域拥有的所有资源，而不会发生泄漏。第四，其他域中的线程会继续执行，并可继续访问由崩溃的域分配、但在崩溃前已转移到其他域的对象。

实施故障隔离具有挑战性。在红叶中，隔离的子系统输出复杂、语义丰富的接口，也就是说，域可以自由交换对接口和对象层次结构的引用。我们做出了几种设计选择，使我们能够干净利落地封装域的状态，同时支持语义丰富的接口和零拷贝通信。

#### 3.1.1 堆隔离与共享

**私有和共享堆：** 为了提供跨域的故障隔离并确保域的安全终止，我们要保证跨域堆隔离，即域的私有堆、堆栈或全局数据部分上分配的对象不能从域外访问。这个约束允许我们在执行的任何时刻安全地终止任何域。由于没有其他域持有指向已终止域的私有堆的指针，因此删除整个堆是安全的。

为了支持高效的跨域通信，我们为可跨域发送的对象提供了一个特殊的全局共享堆。域在共享堆上分配对象的方式与 Rust `Box<T>` 类型在普通堆上分配 `T` 类型的值类似。我们构建了一种特殊类型，即远程引用或 `RRef<T>` ，它可以在共享堆上分配 `T` 类型的值（[图 2]()）。 `RRef<T>` 由两部分组成：一个小的元数据和值本身。 `RRef<T>` 元数据包含当前拥有引用的域的标识符、借用计数器和值的类型信息。`RRef<T>` 元数据和值在共享堆上分配，允许 `RRef<T>` 在最初分配它的域之后继续存在。

**私有堆中的内存分配：** 为了对域的私有堆进行封装，我们采用了两级内存分配方案。在底部，微内核为域提供了一个接口，用于分配无类型的粗粒度内存区域（大于一个页面）。每次粗粒度分配都会记录在*堆注册表*中。要在域的私有堆上进行精细类型分配，每个域都要与提供 Rust 内存分配接口 `Box<T>` 的可信包进行链接。域堆分配遵循 Rust 的所有权规则，即对象超出作用域时会被重新分配。两级方案有以下优点：只分配大内存区域，微内核记录域分配的所有内存，而不会产生显著的性能开销。如果该域发生恐慌，微内核会遍历分配给该域的分配器所分配的所有未类型化内存区域的注册表，并在不调用任何析构函数的情况下将其注销。这种无类型、粗粒度的回收是安全的，因为我们确保了堆隔离约束：其他域对回收的堆没有引用。

#### 3.1.2 可交换类型

在共享堆上分配的对象必须遵守以下规则：它们只能由可交换类型组成。可交换类型确保以下约束：共享堆上的对象不能有指向私有堆或共享堆的指针，但可以有指向共享堆上分配的其他对象的 `RRef` 。红叶的 IDL 编译器在生成域的接口时会验证这一不变式（[第 3.1.5 节]()）。我们将可交换类型定义为以下集合： 1） RRef 本身，2）Rust 原始 `Copy` 类型的子集，如 `u32`、`u64`，但不包括一般情况下的引用，也不包括指针，3）由可交换类型构建的匿名（元组、数组）和命名（枚举、结构体）复合类型，4）对具有接收可交换类型方法的`trait`的引用。此外，所有trait方法都必须遵循以下调用约定，要求这些方法返回 `RpcResult<T>` 类型，以支持从崩溃域返回的线程的简洁中止语义（[第 3.1 节]()）。IDL 会检查接口定义，并验证所有类型是否格式正确（[第 3.1.5 节]()）。

#### 3.1.3 所有权追踪

在红叶中，`RRef<T>` 可以在域之间自由传递。我们允许 `RRef<T>` 被移动或不可变借用。不过，我们对 `RRef<T>` 实施了所有权约束，在跨域调用时保证。通过所有权跟踪，我们可以安全地删除崩溃域所拥有的共享堆上的对象。`RRef<T>` 的元数据部分会记录所有者域和跨域调用时的借用次数。

最初，`RRef<T>` 由分配引用的域所有。如果在跨域调用中将引用转移到另一个域，我们就会更改 `RRef<T>` 中的所有者标识符，将所有权从一个域转移到另一个域。所有跨域通信都由可信代理进行中转，因此我们可以通过代理安全地更新所有者标识符。Rust 的所有权规范确保域内对象始终只有一个远程引用，因此当引用在跨域调用时在域之间移动时，调用者将失去对传递给被调用者的对象的访问权限。如果引用在跨域调用中被不可变借用，我们不会更改 `RRef<T>` 中的所有者标识符，而是递增跟踪 `RRef<T>` 被借用次数的计数器。

**递归引用** `RRef<T>` 可以形成对象的层次结构。为了避免在跨域调用时递归移动层次结构中的所有 `RRef<T>` ，只有对象层次结构的根节点才有有效的所有者标识符（[图 2]() 中只有对象 `X` 有有效的域标识符 `A`，对象 `Y` 没有）。在跨域调用时，根 `RRef<T>` 会被代理更新，从而更改域标识符，在域之间移动 `RRef<T>` 的所有权。这就需要一个特殊的方案，以便在发生崩溃时取消 `RRef<T>` 的分配：我们扫描整个 `RRef<T>` 注册表，清理崩溃域所拥有的资源。为了防止删除层次结构中的子对象，我们的做法是，这些子对象没有有效的 `RRef<T>` 标识符（我们在扫描过程中跳过它们）。根 `RRef<T>` 对象的 `drop` 方法会遍历整个层次结构，并重新分配所有子对象（`RRef<T>` 不能形成循环）。请注意，我们应该小心处理 `RRef<T>` 从层次结构中移出的情况。为了正确地重新分配 `RRef<T>`，我们需要给它分配一个有效的域标识符，也就是说，当 `Y` 从 `X` 移出时，它就会得到一个正确的域标识符。我们用可信的访问器方法对 `RRef<T>` 字段分配进行中转。我们生成的访问器方法提供了从对象字段中取出 `RRef<T>` 的唯一方法。这样，我们就可以对移动操作进行中转，并更新被移动 `RRef<T>` 的域标识符。请注意，对于未命名的复合类型（如数组和元组），无法强制执行访问器。对于这些类型，我们会在跨越域边界时更新所有复合元素的所有权。

**回收共享堆** 通过所有权跟踪，我们可以回收当前由崩溃域拥有的对象的内存。我们对所有已分配的 `RRef<T>` 进行全局注册（[图 2]()）。当域发生恐慌时，我们会浏览注册表，并删除崩溃域拥有的所有引用。如果 `RRef<T>` 被借用，我们会推迟回收，直到借用次数降为零。要取消每个 `RRef<T>` 的分配，我们必须为每种 `RRef<T>` 类型提供一个 `drop` 方法，并能动态识别引用的类型。每个 `RRef<T>` 都有一个由 IDL 编译器生成的唯一类型标识符（IDL 知道系统中的所有 `RRef<T>` 类型，因为它生成了所有跨域接口）。我们将类型标识符与 `RRef<T>` 一起存储，并调用适当的 `drop` 方法来正确地删除共享堆上任何可能的分层数据结构。

#### 3.1.4 跨域调用代理

为了实现故障隔离，红叶依靠调用代理对所有跨域调用进行干预（[图 2]()）。代理对象暴露的接口与其所中转的接口完全相同。因此，代理干预对接口用户来说是透明的。为确保隔离性和安全性，代理在每个封装函数中实现了以下功能： 1）在执行调用之前，代理会检查域是否存活。如果域还存活，代理会通过更新微内核中的线程状态来记录线程在域之间移动的事实。当域崩溃时，我们会利用这一信息来解绑所有恰好在域内执行的线程。2）对于每次调用，代理都会创建一个轻量级的继续，以捕获跨域调用前的线程状态。该继续允许我们解绑线程的执行，并向调用者返回错误信息。3）代理在域之间移动作为参数传递的所有 `RRef<T>` 的所有权，或更新所有借用引用的借用计数，使其保持不变。4）最后，代理会封装所有作为参数传递的trait引用：代理会为每个trait创建一个新的代理，并传递该代理实现的trait的引用。

**线程解绑** 要从崩溃域解绑线程的执行，我们需要捕捉线程进入被调用者域之前的状态。对于代理所介导的每个trait函数，我们都会使用一个汇编蹦床（trampolime），将所有通用寄存器保存到一个*继续*中。微内核为每个线程维护一个继续栈。每个继续都包含所有通用寄存器的状态和一个指向错误处理函数的指针，该函数的签名与域接口导出的函数相同。如果必须解绑线程，我们会将堆栈恢复到继续所捕获的状态，并在相同的堆栈上以相同的通用寄存器值调用错误处理函数。错误处理函数会向调用者返回错误信息。

为了在崩溃时干净地返回错误，我们对所有跨域调用执行了以下调用约定：每个跨域函数都必须返回 `RpcResult<T>`，这是一种枚举类型，其中要么包含返回值，要么包含错误（[图 3]()）。这样，我们就可以实现以下约束：从崩溃域中解绑的函数永远不会返回损坏的数据，而是返回一个 `RpcResult<T>` 错误。

#### 3.1.5 接口验证

红叶的 IDL 编译器负责验证域接口，并生成在共享堆上执行所有权规范所需的代理代码。红叶 IDL 是 Rust 的一个子集，扩展了多个属性以控制代码的生成（[图 3]()）。这种设计选择使我们能够为开发人员提供熟悉的 Rust 语法，并重新使用 Rust 的解析基础架构。

要实现接口的抽象，我们需要依赖 Rust 的*trait*。trait提供了一种定义方法集合的方法，类型必须实现这些方法才能满足trait的要求，从而定义了特定的行为。例如，`BDev` trait要求任何提供该trait的类型实现两个方法：`read()` 和 `write()`（[图 3]()）。通过交换对trait对象的引用，域可连接到系统的其他部分，并与其他域建立通信。


**接口检验**

### 3.2 零复制通信

## 4 实现

### 4.1 微内核


### 4.2 动态加载域


**代码生成**

### 4.3 安全设备驱动


### 4.4 设备驱动恢复


### 4.5 Rv6 操作系统特性

## 5 评估

### 5.1 域隔离的开销

**基于语言的隔离 vs 硬件**

**Rust的开销**

### 5.2 设备驱动


#### 5.2.1 Ixgbe 网络驱动


**Nullnet**

#### 5.2.2 NVMe 驱动


### 5.3 应用测试

**Maglev负载平衡器**

**kv-store键值储存**

**httpd网络服务器**

### 5.4 驱动恢复


## 6 相关工作
