# 红叶：安全操作系统中的隔离与通信

Vikram Narayanan, Tianjiao Huang, David Detweiler, Dan Appel, and
Zhaofeng Li, University of California, Irvine; Gerd Zellweger, VMware Research; 
Anton Burtsev, University of California, Irvine

本文被收录于第 14 届 USENIX 操作系统设计与实现研讨会论文集设计与实现
2020年11月 4-6

对第 14 届 USENIX 操作系统设计与实现研讨会论文集设计与实现的开放访问由USENIX赞助

## 摘要

红叶（RedLeaf）是一个从零开始用 Rust 开发的新操作系统，旨在探索语言安全对操作系统组成的影响。与商业系统相比，RedLeaf 不依赖硬件地址空间进行隔离，而只依靠 Rust 语言的类型和内存安全。脱离昂贵的硬件隔离机制让我们得以探索轻量级细粒度隔离系统的设计空间。我们开发了一个新的基于语言的轻量级隔离域的抽象，它提供了一个信息隐藏和故障隔离的单元。 域能够被动态地加载并干净地终止，即一个域中的错误不会影响其他域的运行。在 RedLeaf 隔离机制的基础上，我们展示了实现设备驱动程序的端到端零拷贝、故障隔离和透明恢复的可能性。为了评估 RedLeaf 其抽象的实用性。我们把Rv6，一个POSIX子集操作系统实现成了若干个 RedLeaf 域的集合。最后，为了证明 Rust 和细粒度隔离的实用性，我们开发了 10Gbps 英特尔 ixgbe 网卡和 NVMe 固态硬盘设备驱动程序的高效版本，其性能可与最快的 DPDK 和 SPDK 相媲美。

## 1 引入

四十年前，早期的操作系统设计认为隔离内核子系统的能力是提高整个系统可靠性和安全性的关键机制[^12,32]。 遗憾的是，尽管多次尝试在内核中引入细粒度隔离，但现代系统仍然是庞大且单一（monolithic）的。一直以来，软件和硬件机制对于高性能要求的子系统隔离来说过于昂贵。多个硬件项目探索了在硬件中实现细粒度、低开销隔离机制的能力 [^84,89,90]。然而，着眼于性能，现代商品 CPU只为用户程序的粗粒度隔离提供了基本支持。同样，几十年来，能在软件层面提供细粒度隔离的安全语言对于低级的操作系统代码来说开销仍然过高。传统上，安全语言需要一个可管理的运行时，特别是垃圾回收机制来实现安全。尽管垃圾回收技术取得了许多进步，但对于每个核心每秒处理数百万个请求的系统来说，垃圾回收的开销仍然很高（在典型的设备驱动程序工作情形中，最快的垃圾回收语言比 C 语言慢 20-50%[^28]）。

几十年来，打破单一内核的设计选择仍然不切实际。因此，现代内核缺乏隔离性及其优势：简洁的模块化、信息隐藏、故障隔离、透明的子系统恢复和细粒度访问控制。

随着 Rust 的发展，隔离和性能之间的历史平衡正在发生变化。Rust 可以说是第一种在没有垃圾回收的情况下实现安全性的实用语言[^45]。Rust 将旧的线性类型 [^86] 思想与实用的语言设计相结合，通过一个受限的所有权模型来实现类型和内存安全，允许内存中的每个生存对象只有唯一一个引用。这样就可以静态跟踪对象的生命周期，并在不使用垃圾回收器的情况下将其删除。该语言的运行时开销仅限于边界检查，且在许多情况下，现代超标量无序 CPU 可以隐藏边界检查，并预测和执行不进行检查时的正确路径 [^28]。为了实现实用的非线性数据结构，Rust 提供了一小套精心挑选的基本类型，可以摆脱线性类型系统的严格限制。

Rust 作为一种开发底层系统的工具，迅速受到人们的欢迎，而传统上这些系统都是用 C 语言开发的 [4, 24, 40, 47, 50, 65]。低开销安全带来了一系列立竿见影的安全优势————预计三分之二由典型的不安全低级语言编程习惯引起的漏洞，仅通过使用安全语言就可以消除 [^20,22,67,69,77] 。

遗憾的是，最近的项目大多把 Rust 作为 C 语言的一种替换。然而，我们认为，语言安全的真正好处在于可以实现实用、轻量级、细粒度的隔离，以及一系列几十年来一直是操作系统研究重点但却无法实用的机制：故障隔离[79]、透明设备驱动恢复[78]、安全内核扩展[13,75]、基于能力的细粒度访问控制[76]等等。

红叶 [^在叶片组织中生成的锈(Rust)菌会使叶片变红] 是一个新的操作系统，旨在探索语言安全对操作系统组成的影响，特别是在内核中利用细粒度隔离的能力及其优势。RedLeaf 是用 Rust 从零开始实现的。它不依赖硬件机制进行隔离，而只使用 Rust 语言的类型和内存安全。

尽管有多个项目在探索基于语言的系统中的隔离问题 [^6,35,39,85] ，但在 Rust 中阐明隔离原则并提供实用的实现仍然具有挑战性。一般来说，安全语言会提供一些机制来控制对单个对象字段的访问（例如 Rust 中的 `pub` 访问修饰符），并保护指针，即限制对通过可见全局变量和显式传递参数可获取的程序状态的访问。通过对引用和通信渠道的控制，可以在函数和模块边界上隔离程序的状态，以确保保密性和完整性，更广泛地说，可以通过对象能力语言[^59]所探索的一系列技术来构建全面的最小权限系统。

不幸的是，仅靠内置语言机制不足以对互不信任的系统实现隔离，如依赖语言安全隔离应用程序和内核子系统的操作系统内核。为了保护整个系统的执行，内核需要一种隔离故障的机制，即提供一种终止故障或行为不端计算的方法，使系统处于干净的状态。具体来说，在子系统终止后，隔离机制应提供途径来做到：1）取消分配给子系统使用的所有资源；2）如果一个子系统分配的对象已通过通信通道传递给其他子系统，保留它；以及 3）确保今后对已终止子系统所暴露接口的所有调用都不会违反安全规定或阻塞调用者，而是返回错误信息。面对基于语言的系统所鼓励的语义丰富的接口，故障隔离是一项挑战————频繁的引用交换往往意味着单个组件的崩溃会使整个系统处于损坏状态[^85]。

从早期的单用户、单语言、单地址空间设计 [^9,14,19,25,34,55,71,80] 到堆隔离 [^6,35] 以及使用线性类型来实现堆隔离 [^39] ，多年来，在基于语言的系统中隔离计算的目标已经走过了漫长的道路。尽管如此，如今人们对基于语言的隔离原理还不甚了解。在 Sing# 中实现故障隔离的 Singularity [^39] 依靠语言和操作系统的紧密协同设计来实现隔离机制。且最近几个提出使用 Rust 实现轻量级隔离的系统，如 Netbricks [^68] 和 Splinter [^47]，都难以阐明实现隔离的原则，而只是用 Rust 已经提供的信息隐藏来代替故障隔离。类似的，最近推出的 Rust 操作系统 Tock 通过传统的硬件机制和受限的系统调用接口支持用户进程的故障隔离，但却无法为安全 Rust 实现的设备驱动程序（胶囊）提供故障隔离 [^50] 。

我们的工作是开发安全语言的故障隔离原则和机制。我们引入了一种基于语言的隔离域抽象，作为信息隐藏、加载和故障隔离的单元。为了封装域的状态并在域边界实现故障隔离，我们制定了以下原则：

- **堆隔离** 我们将堆隔离作为对所有域的约束（invariant），即各域绝不持有指向其他域私有堆的指针。堆隔离是终止和卸载崩溃域的关键，因为没有其他域持有指向崩溃域私有堆的指针，所以卸载整个私有堆是安全的。为了实现跨域通信，我们引入了一种特殊的共享堆，允许分配可在域之间交换的对象。
- **可交换类型** 为了实现堆隔离，我们引入了可交换类型的概念，即在不泄漏指向私有堆的指针的情况下，可以安全地跨域交换的类型。可交换类型允许我们静态地实现一个约束，即在共享堆上分配的对象不能有指向私有域堆的指针，但可以有指向共享堆上其他对象的引用。
- **所有权追踪** 为了取消崩溃域在共享堆上拥有的资源，我们会跟踪共享堆上所有对象的所有权。当一个对象在域之间传递时，我们会根据它是在域之间移动还是在只读访问中被借用来更新其所有权。
- **接口验证** 
- **跨域调用代理** 





利用语言提供的内存和类型安全来实现错误隔离。

划分出了多个域。制定了以下原则：
+ 堆隔离：安全中止并卸载出错的域
	+ 共享堆：跨域交换对象
+ 可交换类型：共享堆中的对象只能指向共享堆，不能指向私有堆
+ 所有权追踪：回收共享堆中出错域申请的资源，使用rust语言机制确保跨域调用时所有权转移
+ 接口检验：跨域调用只允许可交换类型。用自定义语言静态检查，生成实现。
+ 跨域调用代理：更新所有权，处理调用

一个域出错时，中止其中所有线程，回收资源。对它的调用返回错误。已离开该域的对象保持可用。

实现了Rv6，提供细粒度隔离，错误隔离，e2e无复制通信，用户级驱动，内核旁路

## 2 基于语言的系统隔离

J-Kernel：共享内存+包装。出错时垃圾回收。运行时检查接口。有限的错误隔离：错误传递、深复制。

KaffeOS：写屏障（共享堆不能指向私有堆，跨域调用时引用计数与垃圾回收）。错误隔离：保留共享对象（该对象可能在更新到一半时出错，导致状态不合法），深复制。

Sigularity OS：共享堆+私有堆，单一所有权。0复制。基于Sing#语言。

RedLeaf：用代理包装接口，静态提高性能。私有堆隔离。共享堆单一所有权，0复制，只读引用->透明域恢复。用抽象的原则代替语言机制。

## 3 架构

跨域调用时，线程在域之间移动，但不改变栈。
使用trait

**保护模型**：
信任rust编译器、使用非安全代码的包。构建与硬件的交互。
信任硬件。（将来使用IOMMU保护物理内存）
不处理侧信道攻击

### 3.1 域和错误隔离

域是基本单位。驱动、内核各个子系统、用户应用都作为域。
每个域初始接受一个参数：内核接口。
域可自定义入口函数接口。
内核不新建线程，域可以在init()中新建线程。进入别的域的线程将被保留，直到返回这个线程（已终止）

**错误隔离**：
崩溃：其中任一线程恐慌。
隔离：
- 把入口和内部线程解绑，对它的创建者返回错误
- 任何之后的调用尝试返回错误
- 回收所有资源
  > [!info] 如果共享堆中一个物体所有权的域崩溃了，而别的域有引用指向它呢？
  > 可能有这种情况出现吗？
  > 见下：不可能
- 已转移的线程保持运行

#### 3.1.1 堆隔离与共享

**私有和共享堆：**
私有堆只允许域类引用。
`RRef<T>`可以申请共享堆。元数据：当前拥有它的域，借用计数器，值的类型。

**私有堆中的内存分配：**
二级内存分配。
- 下层，内核为域提供分配粗糙大段内存的接口
- 上层，域调用rust包，提供精细内存分配。

#### 3.1.2 可交换类型

共享堆中的对象只能是可交换类型。
确保没有指向私有堆的指针，只有RRef指向同在共享堆中的对象。IDL实现。

可交换类型：
- RRef
- Rust中有Copy的基本类型，去除指针和引用
- 可交换类型组成的组合类型
- 指向trait的引用，其中方法只接受可交换类型
  > [!question] trait 引用是什么玩意
  > 就是一个跨域接口？

trait 方法必须返回`RpcResult<T>`

#### 3.1.3 所有权追踪

对于`RRef<T>`，可以转移所有权或者不可变引用。

**递归引用：**
RRef组成的多层引用结构中，只有根的owner状态有效。
所有共享堆中的对象存在注册表中，崩溃时扫描注册表，跳过owner无效的对象。
一个内部对象移出的时候，需要加上正确的owner。确保只有唯一的访问器方法可以从RRef内取出一个RRef。访问器方法对无名组合类型无效（数组、元组），它们会在穿过域边界时更新所有权。
> [!question] 什么穿过域边界

**回收共享堆：**
推迟回收被借出的对象。
> [!info] 可以推迟吗？还能隔离错误吗？
可以：Rust保证只能有不可变借用。可变借用拿走了所有权。

drop函数知道对象的类型，调用适当的回收函数。

#### 3.1.4 跨域调用代理

跨域调用代理
1. 检查对方域是否存活。存活则更新线程owner。
2. 创建一个继续，控制线程。
3. 处理RRef参数的所有权、借用计数
4. 包裹所有作为参数的trait引用：对每个trait创建新代理，把引用传给(改为？)代理实现的trait
  > [!question] trait 引用是什么玩意，这段在说啥

**线程解绑：**
在传入前，掌控线程状态。
对每个代理管理的trait函数，用汇编蹦床保存通用寄存器到一个继续。
对每个线程，内核维护一个继续组成的栈。
每个继续保存了所有通用寄存器，和一个指针指向错误处理函数，它与被调用的函数签名一致。
如果我们需要解绑线程，先恢复栈和寄存器，再调用错误处理函数，返回一个错误给调用者。

确保：
每个跨域函数返回`RpcResult<T>` -> 调用域崩溃时可以返回一个错误

#### 3.1.5 接口检查

IDL使用trait来描述接口，在域和系统之间传递指向trait的指针。
每个域需要一个`#[create]`的trait。返回域本身`Domain`和接口trait `BDev`。
IDL生成trait代码和内核中调用这个trait接口的代码。

**接口检验：**
通过IDL编译器的静态分析。
生成AST并检验。使用一张图表示类型间关系，检验每个类型都是可交换的，每个约束都被满足。

### 3.2 零复制通信

用rust的移动借用原则来满足。
不允许可变借用，必须显式借用和返回，以隔离崩溃。

零复制在透明恢复时有困难。一般做法是重启崩溃的域并重新调用。
重新调用这里需要参数。不可变借用可以再次传入。
> [!question] move参数的调用不能透明恢复？直接返回错误还是复制一个再试？

## 4 实现

### 4.1 微内核

内存分配：每个域独立，直接向内核申请。
用汇编实现中断进入和退出。
设备驱动由用户域实现。域注册一个中断处理的线程。之后遇到中断时，交由内核管理，中断结束后返回运行队列。

### 4.2 动态加载域

域独立编译并被内核动态加载。（Rust不支持动态链接）
动态扩展的安全性在于：用于跨域通信的各个类型有相同的定义和实现。这保证了分别编译的代码在跨域时也有类型安全性保证。
使用 *信任编译环境* 。在编译时 环境对IDL文件和编译标志flag进行签名。内核加载时验证。
限制域只能用safe rust，只能链接白名单的库。

**代码生成：**
IDL编译器生成域代码并加载。
接口定义trait，域创建trait
-> 上2个，域入口函数，内核创建函数，接口的调用代理

### 4.3 安全设备驱动

驱动域是普通用户域。内核提供信任的crates，提供访问硬件的接口。
系统引导时，init域创建驱动域。每个PCI设备获得一个PCI trait的引用，此trait在pci域中实现。
受信任的包构建BARAddr对象，含有pci设备的BAR区域地址。用一个自定义的类型保护每个BARAddr，使之只能在受信的实现了访问BAR区域的包内被访问。
pci域查探匹配设备标示符的驱动。驱动获得一个BARAddr的引用，并以此操作硬件。

### 4.4 设备驱动恢复

影子驱动：普通域。类似代理，但是这个更复杂，每个驱动都有不同的恢复协议。
影子驱动保存恢复所需信息（PCI trait的引用，设备初始化歇息要的数据）
崩溃时，受到错误，尝试恢复。

### 4.5 Rv6 操作系统特性

实现Rv6用于评估。
域：内核，fs，网络栈子系统，网络和硬盘驱动，多个用户域。
内核分发用户域的通信给别的OS子系统域（fs，网络栈），fs又与一个块设备驱动通信。
实现了三个块设备驱动：in-内存，AHCI，NVMe。
fs实现了journaling，缓存，inode，命名层。
网络子系统实现了TCP/IP栈，与网络驱动（10Gbps Intel Ixgbe）连接。
没有实现全部的fork语义：不依赖地址空间，因此不能虚拟化和克隆地址空间。提供了create系统调用，创建新的域。
引导进入一个shell，支持管道和IO重定向，启动其他应用。

## 5 评估

测试网络和硬盘。
### 5.1 域隔离的开销

**基于语言的隔离 vs 硬件：**
对比seL，intel MPK，intel EPT（LVD）。后2者需要复杂硬件机制，不支持内核内隔离。
很多cpu支持了特权级隔离，但是单所有权还需编程语言支持。

**Rust的开销：**
用C，Rust，C风格Rust测试散列表。Rust慢25%，C风格Rust不慢。

### 5.2 设备驱动

网卡和硬盘是性能最不溢出的驱动。

#### 5.2.1 Ixgbe 网络驱动

与Linux和DPDK对比。
每层代理Domain/rv6/shadow都会拖慢速度，最低达到DPDK的1/3，远超Linux。

**Nullnet：**
取消设备方面的最大速率限制。代理、域隔离出现了50%-80%的减速。

#### 5.2.2 NVMe 驱动

与Linux和SPDK对比。
linux多数情况极慢，redleaf(和各种代理)和spdk都达到了设备上限。

### 5.3 应用测试

**Maglev负载平衡器：**

**kv-store键值储存：**
不安全Rust会提高性能，但是不允许。

**httpd网络服务器：**

### 5.4 驱动恢复

崩溃时，透明恢复带来了读5%写16%的性能下降。

## 6 相关工作

Rust写的底层高性能系统：数据储存，网络虚拟化，网页引擎，OSs，uni内核，hypervisors。等。
把rust视作C的安全替代。没有探索rust的类型和内存安全。
扩展了Tock工作。它限制了不安全扩展，redleaf加入了错误隔离和动态加载扩展。Netbrick和Splinter用Rust隔离网络功能和用户自定义扩展。
我们实现了崩溃子系统的资源回收，恢复，把引用和接口作为泛型交换。
