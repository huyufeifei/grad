## 1 引入

利用语言提供的内存和类型安全来实现错误隔离。

划分出了多个域。制定了以下原则：
+ 堆隔离：安全中止并卸载出错的域
	+ 共享堆：跨域交换对象
+ 可交换类型：共享堆中的对象只能指向共享堆，不能指向私有堆
+ 所有权追踪：回收共享堆中出错域申请的资源，使用rust语言机制确保跨域调用时所有权转移
+ 接口检验：跨域调用只允许可交换类型。用自定义语言静态检查，生成实现。
+ 跨域调用代理：更新所有权，处理调用

一个域出错时，中止其中所有线程，回收资源。对它的调用返回错误。已离开该域的对象保持可用。

实现了Rv6，提供细粒度隔离，错误隔离，e2e无复制通信，用户级驱动，内核旁路

## 2 基于语言的系统隔离

J-Kernel：共享内存+包装。出错时垃圾回收。运行时检查接口。有限的错误隔离：错误传递、深复制。

KaffeOS：写屏障（共享堆不能指向私有堆，跨域调用时引用计数与垃圾回收）。错误隔离：保留共享对象（该对象可能在更新到一半时出错，导致状态不合法），深复制。

Sigularity OS：共享堆+私有堆，单一所有权。0复制。基于Sing#语言。

RedLeaf：用代理包装接口，静态提高性能。私有堆隔离。共享堆单一所有权，0复制，只读引用->透明域恢复。用抽象的原则代替语言机制。

## 3 架构

跨域调用时，线程在域之间移动，但不改变栈。
