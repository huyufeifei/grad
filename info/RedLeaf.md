## 1 引入

利用语言提供的内存和类型安全来实现错误隔离。

划分出了多个域。制定了以下原则：
+ 堆隔离：安全中止并卸载出错的域
	+ 共享堆：跨域交换对象
+ 可交换类型：共享堆中的对象只能指向共享堆，不能指向私有堆
+ 所有权追踪：回收共享堆中出错域申请的资源，使用rust语言机制确保跨域调用时所有权转移
+ 接口检验：跨域调用只允许可交换类型。用自定义语言静态检查，生成实现。
+ 跨域调用代理：更新所有权，处理调用

一个域出错时，中止其中所有线程，回收资源。对它的调用返回错误。已离开该域的对象保持可用。

实现了Rv6，提供细粒度隔离，错误隔离，e2e无复制通信，用户级驱动，内核旁路

## 2 基于语言的系统隔离

J-Kernel：共享内存+包装。出错时垃圾回收。运行时检查接口。有限的错误隔离：错误传递、深复制。

KaffeOS：写屏障（共享堆不能指向私有堆，跨域调用时引用计数与垃圾回收）。错误隔离：保留共享对象（该对象可能在更新到一半时出错，导致状态不合法），深复制。

Sigularity OS：共享堆+私有堆，单一所有权。0复制。基于Sing#语言。

RedLeaf：用代理包装接口，静态提高性能。私有堆隔离。共享堆单一所有权，0复制，只读引用->透明域恢复。用抽象的原则代替语言机制。

## 3 架构

跨域调用时，线程在域之间移动，但不改变栈。
使用trait

**保护模型**：
信任rust编译器、使用非安全代码的包。构建与硬件的交互。
信任硬件。（将来使用IOMMU保护物理内存）
不处理侧信道攻击

### 3.1 域和错误隔离

域是基本单位。驱动、内核各个子系统、用户应用都作为域。
每个域初始接受一个参数：内核接口。
域可自定义入口函数接口。
内核不新建线程，域可以在init()中新建线程。进入别的域的线程将被保留，直到返回这个线程（已终止）

**错误隔离**：
崩溃：其中任一线程恐慌。
隔离：
- 把入口和内部线程解绑，对它的创建者返回错误
- 任何之后的调用尝试返回错误
- 回收所有资源
  > [!info] 如果共享堆中一个物体所有权的域崩溃了，而别的域有引用指向它呢？
  > 可能有这种情况出现吗？
  > 见下：不可能
- 已转移的线程保持运行

#### 3.1.1 堆隔离与共享

**私有和共享堆：**
私有堆只允许域类引用。
`RRef<T>`可以申请共享堆。元数据：当前拥有它的域，借用计数器，值的类型。

**私有堆中的内存分配：**
二级内存分配。
- 下层，内核为域提供分配粗糙大段内存的接口
- 上层，域调用rust包，提供精细内存分配。

#### 3.1.2 可交换类型

共享堆中的对象只能是可交换类型。
确保没有指向私有堆的指针，只有RRef指向同在共享堆中的对象。IDL实现。

可交换类型：
- RRef
- Rust中有Copy的基本类型，去除指针和引用
- 可交换类型组成的组合类型
- 指向trait的引用，其中方法只接受可交换类型
  > [!question] trait 引用是什么玩意
  > 就是一个跨域接口？

trait 方法必须返回`RpcResult<T>`

#### 3.1.3 所有权追踪

对于`RRef<T>`，可以转移所有权或者不可变引用。

**递归引用：**
RRef组成的多层引用结构中，只有根的owner状态有效。
所有共享堆中的对象存在注册表中，崩溃时扫描注册表，跳过owner无效的对象。
一个内部对象移出的时候，需要加上正确的owner。确保只有唯一的访问器方法可以从RRef内取出一个RRef。访问器方法对无名组合类型无效（数组、元组），它们会在穿过域边界时更新所有权。
> [!question] 什么穿过域边界

**回收共享堆：**
推迟回收被借出的对象。
> [!info] 可以推迟吗？还能隔离错误吗？
可以：Rust保证只能有不可变借用。可变借用拿走了所有权。

drop函数知道对象的类型，调用适当的回收函数。

#### 3.1.4 跨域调用代理

跨域调用代理
1. 检查对方域是否存活。存活则更新线程owner。
2. 创建一个继续，控制线程。
3. 处理RRef参数的所有权、借用计数
4. 包裹所有作为参数的trait引用：对每个trait创建新代理，把引用传给(改为？)代理实现的trait
  > [!question] trait 引用是什么玩意，这段在说啥

**线程解绑：**
在传入前，掌控线程状态。
对每个代理管理的trait函数，用汇编蹦床保存通用寄存器到一个继续。
对每个线程，内核维护一个继续组成的栈。
每个继续保存了所有通用寄存器，和一个指针指向错误处理函数，它与被调用的函数签名一致。
如果我们需要解绑线程，先恢复栈和寄存器，再调用错误处理函数，返回一个错误给调用者。

确保：
每个跨域函数返回`RpcResult<T>` -> 调用域崩溃时可以返回一个错误

#### 3.1.5 接口检查

IDL使用trait来描述接口，在域和系统之间传递指向trait的指针。
每个域需要一个`#[create]`的trait。返回域本身`Domain`和接口trait `BDev`。
IDL生成trait代码和内核中调用这个trait接口的代码。

**接口检验：**
通过IDL编译器的静态分析。
生成AST并检验。使用一张图表示类型间关系，检验每个类型都是可交换的，每个约束都被满足。

### 3.2 零复制通信

用rust的移动借用原则来满足。
不允许可变借用，必须显式借用和返回，以隔离崩溃。

零复制在透明恢复时有困难。一般做法是重启崩溃的域并重新调用。
重新调用这里需要参数。不可变借用可以再次传入。
> [!question] move参数的调用不能透明恢复？直接返回错误还是复制一个再试？

## 4 实现

### 4.1 微内核

内存分配：每个域独立，直接向内核申请。
用汇编实现中断进入和退出。
设备驱动由用户域实现。域注册一个中断处理的线程。之后遇到中断时，交由内核管理，中断结束后返回运行队列。

### 4.2 动态加载域

域独立编译并被内核动态加载。（Rust不支持动态链接）
动态扩展的安全性在于：用于跨域通信的各个类型有相同的定义和实现。这保证了分别编译的代码在跨域时也有类型安全性保证。
使用 *信任编译环境* 。在编译时 环境对IDL文件和编译标志flag进行签名。内核加载时验证。
限制域只能用safe rust，只能链接白名单的库。

**代码生成：**
IDL编译器生成域代码并加载。
接口定义trait，域创建trait
-> 上2个，域入口函数，内核创建函数，接口的调用代理

### 4.3 安全设备驱动

驱动域是普通用户域。内核提供信任的crates，提供访问硬件的接口。
系统引导时，init域创建驱动域。每个PCI设备获得一个PCI trait的引用，此trait在pci域中实现。
受信任的包构建BARAddr对象，含有pci设备的BAR区域地址。用一个自定义的类型保护每个BARAddr，使之只能在受信的实现了访问BAR区域的包内被访问。
pci域查探匹配设备标示符的驱动。驱动获得一个BARAddr的引用，并以此操作硬件。

### 4.4 设备驱动恢复

影子驱动：普通域。类似代理，但是这个更复杂，每个驱动都有不同的恢复协议。
影子驱动保存恢复所需信息（PCI trait的引用，设备初始化歇息要的数据）
崩溃时，受到错误，尝试恢复。

### 4.5 Rv6 操作系统特性

实现Rv6用于评估。
域：内核，fs，网络栈子系统，网络和硬盘驱动，多个用户域。
内核分发用户域的通信给别的OS子系统域（fs，网络栈），fs又与一个块设备驱动通信。
实现了三个块设备驱动：in-内存，AHCI，NVMe。
fs实现了journaling，缓存，inode，命名层。
网络子系统实现了TCP/IP栈，与网络驱动（10Gbps Intel Ixgbe）连接。
没有实现全部的fork语义：不依赖地址空间，因此不能虚拟化和克隆地址空间。提供了create系统调用，创建新的域。
引导进入一个shell，支持管道和IO重定向，启动其他应用。

## 5 评估

测试网络和硬盘。
### 5.1 域隔离的开销

**基于语言的隔离 vs 硬件：**
对比seL，intel MPK，intel EPT（LVD）。后2者需要复杂硬件机制，不支持内核内隔离。
很多cpu支持了特权级隔离，但是单所有权还需编程语言支持。

**Rust的开销：**
用C，Rust，C风格Rust测试散列表。Rust慢25%，C风格Rust不慢。

### 5.2 设备驱动

网卡和硬盘是性能最不溢出的驱动。

#### 5.2.1 Ixgbe 网络驱动

与Linux和DPDK对比。
每层代理Domain/rv6/shadow都会拖慢速度，最低达到DPDK的1/3，远超Linux。

**Nullnet：**
取消设备方面的最大速率限制。代理、域隔离出现了50%-80%的减速。

#### 5.2.2 NVMe 驱动

与Linux和SPDK对比。
linux多数情况极慢，redleaf(和各种代理)和spdk都达到了设备上限。

### 5.3 应用测试

**Maglev负载平衡器：**

**kv-store键值储存：**
不安全Rust会提高性能，但是不允许。

**httpd网络服务器：**

### 5.4 驱动恢复

崩溃时，透明恢复带来了读5%写16%的性能下降。

## 6 相关工作

Rust写的底层高性能系统：数据储存，网络虚拟化，网页引擎，OSs，uni内核，hypervisors。等。
把rust视作C的安全替代。没有探索rust的类型和内存安全。
扩展了Tock工作。它限制了不安全扩展，redleaf加入了错误隔离和动态加载扩展。Netbrick和Splinter用Rust隔离网络功能和用户自定义扩展。
我们实现了崩溃子系统的资源回收，恢复，把引用和接口作为泛型交换。
