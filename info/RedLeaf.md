## 1 引入

利用语言提供的内存和类型安全来实现错误隔离。

划分出了多个域。制定了以下原则：
+ 堆隔离：安全中止并卸载出错的域
	+ 共享堆：跨域交换对象
+ 可交换类型：共享堆中的对象只能指向共享堆，不能指向私有堆
+ 所有权追踪：回收共享堆中出错域申请的资源，使用rust语言机制确保跨域调用时所有权转移
+ 接口检验：跨域调用只允许可交换类型。用自定义语言静态检查，生成实现。
+ 跨域调用代理：更新所有权，处理调用

一个域出错时，中止其中所有线程，回收资源。对它的调用返回错误。已离开该域的对象保持可用。

实现了Rv6，提供细粒度隔离，错误隔离，e2e无复制通信，用户级驱动，内核旁路

## 2 基于语言的系统隔离

J-Kernel：共享内存+包装。出错时垃圾回收。运行时检查接口。有限的错误隔离：错误传递、深复制。

KaffeOS：写屏障（共享堆不能指向私有堆，跨域调用时引用计数与垃圾回收）。错误隔离：保留共享对象（该对象可能在更新到一半时出错，导致状态不合法），深复制。

Sigularity OS：共享堆+私有堆，单一所有权。0复制。基于Sing#语言。

RedLeaf：用代理包装接口，静态提高性能。私有堆隔离。共享堆单一所有权，0复制，只读引用->透明域恢复。用抽象的原则代替语言机制。

## 3 架构

跨域调用时，线程在域之间移动，但不改变栈。
使用trait

**保护模型**：
信任rust编译器、使用非安全代码的包。构建与硬件的交互。
信任硬件。（将来使用IOMMU保护物理内存）
不处理侧信道攻击

### 3.1 域和错误隔离

域是基本单位。驱动、内核各个子系统、用户应用都作为域。
每个域初始接受一个参数：内核接口。
域可自定义入口函数接口。
内核不新建线程，域可以在init()中新建线程。进入别的域的线程将被保留，直到返回这个线程（已终止）

**错误隔离**：
崩溃：其中任一线程恐慌。
隔离：
- 把入口和内部线程解绑，对它的创建者返回错误
- 任何之后的调用尝试返回错误
- 回收所有资源
  > [!info] 如果共享堆中一个物体所有权的域崩溃了，而别的域有引用指向它呢？
  > 可能有这种情况出现吗？
  > 见下：不可能
- 已转移的线程保持运行

#### 3.1.1 堆隔离与共享

**私有和共享堆：**
私有堆只允许域类引用。
`RRef<T>`可以申请共享堆。元数据：当前拥有它的域，借用计数器，值的类型。

**私有堆中的内存分配：**
二级内存分配。
- 下层，内核为域提供分配粗糙大段内存的接口
- 上层，域调用rust包，提供精细内存分配。

#### 3.1.2 可交换类型

共享堆中的对象只能是可交换类型。
确保没有指向私有堆的指针，只有RRef指向同在共享堆中的对象。IDL实现。

可交换类型：
- RRef
- Rust中有Copy的基本类型，去除指针和引用
- 可交换类型组成的组合类型
- 指向trait的引用，其中方法只接受可交换类型
  > [!question] trait 引用是什么玩意
  > 就是一个跨域接口？

trait 方法必须返回`RpcResult<T>`

#### 3.1.3 所有权追踪

对于`RRef<T>`，可以转移所有权或者不可变引用。

**递归引用：**
RRef组成的多层引用结构中，只有根的owner状态有效。
所有共享堆中的对象存在注册表中，崩溃时扫描注册表，跳过owner无效的对象。
一个内部对象移出的时候，需要加上正确的owner。确保只有唯一的访问器方法可以从RRef内取出一个RRef。访问器方法对无名组合类型无效（数组、元组），它们会在穿过域边界时更新所有权。
> [!question] 什么穿过域边界

**回收共享堆：**
推迟回收被借出的对象。
> [!info] 可以推迟吗？还能隔离错误吗？
可以：Rust保证只能有不可变借用。可变借用拿走了所有权。

drop函数知道对象的类型，调用适当的回收函数。

#### 3.1.4 跨域调用代理

跨域调用代理
1. 检查对方域是否存活。存活则更新线程owner。
2. 创建一个继续，控制线程。
3. 处理RRef参数的所有权、借用计数
4. 包裹所有作为参数的trait引用：对每个trait创建新代理，把引用传给(改为？)代理实现的trait
  > [!question] trait 引用是什么玩意，这段在说啥

**线程解绑：**
在传入前，掌控线程状态。
对每个代理管理的trait函数，用汇编蹦床保存通用寄存器到一个继续。
对每个线程，内核维护一个继续组成的栈。
每个继续保存了所有通用寄存器，和一个指针指向错误处理函数，它与被调用的函数签名一致。
如果我们需要解绑线程，先恢复栈和寄存器，再调用错误处理函数，返回一个错误给调用者。

确保：
每个跨域函数返回`RpcResult<T>` -> 调用域崩溃时可以返回一个错误

#### 3.1.5 接口检查

IDL使用trait来描述接口，在域和系统之间传递指向trait的指针。
每个域需要一个`#[create]`的trait。返回域本身`Domain`和接口trait `BDev`。
IDL生成trait代码和内核中调用这个trait接口的代码。

**接口检验：**
通过IDL编译器的静态分析。
生成AST并检验。使用一张图表示类型间关系，检验每个类型都是可交换的，每个约束都被满足。

### 3.2 零复制通信

用rust的移动借用原则来满足。
不允许可变借用，必须显式借用和返回，以隔离崩溃。

零复制在透明恢复时有困难。一般做法是重启崩溃的域并重新调用。
重新调用这里需要参数。不可变借用可以再次传入。
> [!question] move参数的调用不能透明恢复？直接返回错误还是复制一个再试？

## 4 实现
