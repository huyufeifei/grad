## 1. 选题依据

操作系统最初是为了在计算机上调度硬件资源，同时执行多个任务而出现。之后随着计算机硬件与软件不断发展。当前主流的操作系统是如Windows和Linux之类的宏内核操作系统，他们的特点是包含了操作系统所需要的大部分功能。这带来潜在的安全性隐患：操作系统中产生的任一错误可能令整个系统崩溃。  
在现代操作系统开发中，安全性的重要程度愈发凸显。这促使开发者寻找一个能够尽可能减少操作系统出错的解决方案。这种情况下微内核的概念逐渐产生。微内核尽可能的精简操作系统本身的复杂度，同时把需要的功能（如文件系统、硬件驱动等程序）放到用户态来完成，这令开发和维护的难度减小，降低了产生漏洞的可能性。同时，运行在用户态的操作系统子模块权限降低，也能够防止一部分攻击。  
现有的操作系统安全解决方案，大多基于硬件上的隔离，如ARM TrustZone。该方案划分出一个受信区域，只允许对安全性要求较高的程序在其中运行，保证与普通区域的完全隔离。  
然而，现有的硬件隔离措施存在一些问题。首先，它们需要特定的硬件支持，这导致了较高的成本并且缺乏普适性。其次，在实现上可能存在错误，从而引入漏洞。  
为了改进现有缺点，考虑基于软件的安全隔离方案。目前已有的工作如RedLeaf，Theseus等都旨在通过软件的设计和编写来提高安全性。基于软件的安全隔离方案有望提供更高的灵活性和适应性，并且可以在各种硬件平台上实施。这些技术的发展将有助于提高操作系统的安全性，并降低系统崩溃和漏洞的风险。

## 2. 研究目标和内容

研究目标：  
实现基于Rust语言支持的错误隔离的操作系统内核。  
研究内容：  
本研究项目尝试把内核划分为多个域；把Rust语言中单一所有权、生命周期追踪等概念引入操作系统内核设计与实现中，实现域间隔离的同时尽可能降低通信开销；使用safe rust所提供的操作安全性来进行错误隔离，阻止非法操作。

## 3. 研究方案

此方案建立在把内核划分为多个域的基础上，对各个域进行隔离，以求阻止域间不受控制的相互干扰，只传递期望的信息。  
同时，为每个域分配私有堆，额外创建一个共享堆。

主要的目标有：内存隔离、故障隔离和故障恢复。

### 故障隔离

当一个域内某线程发生崩溃时，我们认为这个域整体已经崩溃。我们希望做到以下这些事：  
1. 向创建此域（在等待调用结果）的目标返回一个错误信息，告知其域崩溃的信息。该目标需要自行处理这个崩溃错误。
2. 之后任何对此域内对象的调用都将直接返回错误。
3. 域分配的任何资源都会被回收。这包括它的私有堆和共享堆中所有权归属于它的对象。
	- 此处的特例是共享堆中它借出的不可变引用：直到所有的引用都结束为止这个对象将会保留。
4. 它创建的进程/分配的资源中，如果有已经离开此域/所有权不归属于它的，将不受影响。

为了实现以上隔离措施，我们分别进行如下设计：
1. 首先，我们强制要求所有的跨域调用的返回值是一个`RpcResult<T>`类型，这可以确保我们能返回一个错误，且调用方需要处理这个可能的错误。  
   其次，为了成功返回，我们可能需要把处理器的执行情况返回到调用开始的那一刻。我们引入一个调用代理作为中间件，同时引入一个数据结构`continuation`用于保存寄存器和崩溃处理函数入口。调用时，首先来到代理处，我们通过一段汇编代码保存现在的各个寄存器状况和入口到一个`continuation`中。之后进行正常的调用。  
   当出现错误时，我们使用保存的信息进行恢复。之后代理返回错误。
2. 为每一个域引入一个静态变量表示其状态。创建时激活，崩溃时非激活。新调用需先检查此变量。这个静态变量存在于接口包中，此包为域提供了交互的能力，所有域都必须包含它。
3. 域首先向内核申请以页为单位的大片内存。这些内存组成域的私有堆，被内核所记录。当域崩溃时，私有堆被全部回收。我们通过对接口函数定义的检查（IDL编译器），来确保不会有指向私有堆内的指针被跨域传输，这使得别的域不会引用私有堆，它能够被安全的释放。
4. 同上条，能够被转移的，只能是共享堆中的对象。此时rust语言会要求原拥有者（崩溃的域）交出其所有权，之后原来的域就失去了一切权限。而回收资源时不会回收没有所有权的资源。

### 内存隔离

由于为每个域分配了私有堆，我们还要设法禁止域内对另一域所拥有的私有内存进行的访问。相比于传统方案中主要通过硬件来解决，我们尝试通过限制域内代码使用safe rust编写，来禁止裸指针的产生和转化。没有了这些操作，一个域能获得的指针只能是自己内部新创建的或者作为参数传递进来的。前者显然不会指向其他域的私有堆；后者由我们定义的接口规则（IDL编译器）来保证。

我们规定接口表示为trait形式，并被IDL编译器静态检查后，生成代理代码。  
此处的检查就包含了对可传递参数类型的检查：对于指针，只允许指向类接口`Box<dyn xxDomain>`或者共享堆`RRef<T>`的指针通过，不允许指向私有堆的指针。

### 故障恢复

对于部分被隔离的模块，如硬件驱动，我们希望它们能自动进行恢复，而无需手动恢复，页无需调用者重新发起调用。  
一个崩溃的发生，可能是偶然性因素导致的，此时重启该模块就可能解决问题。不过这个方法的局限性在于无法解决本身逻辑就有问题的调用。因此在若干次尝试失败后，应该放弃恢复。  
我们在调用该域时，先对参数进行保存以应对可能需要的恢复。在域崩溃发生后，它的资源被全部回收。我们的处理函数重新创建一个域，将其初始化，并使用保存的参数进行相同的调用。此时就完成了一次对调用者无感的崩溃-恢复过程。

## 4. 研究计划及进度安排

在指导教师指导下阅读国内外⽂献和⾃学相关知识。（1-4周）  
基于前序的知识学习，设计基于Rust语⾔⽀持的隔离⼿段并应⽤到内核⼦系统上。（5-11周）  
完成本科⽣毕业设计（论⽂）外⽂翻译。（第 1 周-第 7 周）  
完成毕业论⽂，提交软件及相关⽂档。（第 13 周-第 14 周）  
完成本科⽣毕业设计（论⽂）答辩。（第 15 周）

## 5. 创新点及预期研究成果

本项目的理念很大程度受到RedLeaf的启发。但是RedLeaf的代码实现有不完善之处，缺乏一些提到的特性。  
目标成果是完成一个操作系统内核，按照上述的方案实现，达到目标的隔离与恢复效果。探讨类型安全的语言（Rust）在操作系统内核开发中的使用场景，提高内核的安全性。  
我将与陈林峰学长一同工作。其中陈林峰已经完成了解决方案的初步设计和原型系统的编写，我将在他的工作基础上加入，参与讨论设计，完成系统中部分代码的编写。

## 6. 参考文献

