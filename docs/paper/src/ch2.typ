= 第二章 系统设计

为了实现项目的目标，即提高操作系统的健壮性与安全性，Alien使用了多种设计模式和约束。如模块化操作系统各组件、严格的隔离机制、各部分的动态加载与替换。这些新概念的引入使我们可以探究下一代操作系统可能的形式，为用户带来更加优秀的使用体验。

== 模块化

Alien采用了微内核的设计，因此可以把文件系统、驱动等部分从内核中独立出来，内核中仅含有必要部分。而在这之上，微内核本身的功能也被划分为内存管理、任务调度、系统调用等多个不同的部分。

在内核中使用模块化的好处与在应用软件中使用模块化的好处一致：内核的各个部分将会高内聚和低耦合。（1）模块之间的分离带来了更小的开发和编译单元，这使得每个单元内部独立的测试会更加容易，减少了出现错误的可能性，同时在出现问题进行调试的时候，也可以快速直观的通过检查穿过接口的数据来对错误进行定位，让开发过程更有效率；（2）让代码各部分的分工更加明确，易于阅读，提高设计和实现的一致性；（3）可以拥有更加细粒度的权限赋予、功能划分。这使得完成某一功能的代码不会被授予需要之外的权限。权限的最小化降低了漏洞和恶意代码带来的风险。

Alien中被划分出来的各模块包括内存管理、互斥锁、常量与类型定义、系统配置、架构、硬件平台、文件系统、各设备驱动、任务调度器、系统调用、日志等。其中部分模块可以在github[os-module]上找到。

== 隔离域

隔离域是Alien中的一个隔离单位。它将会被独立编译，并且需要满足开发者规定的一些安全性约束，如内存、接口、源码层面的。在Alien中，大量的模块都被写成了隔离域。而剩下一些无法作为隔离域存在的模块则归入可信代码块（TCB）。

内核中对于隔离域的处理使用了一个加载器模块。同时，为了给隔离域提供它所要依赖的功能，还有专门的一个包用于隔离域和内核的交互。隔离域所需的函数有申请可交互结构（在共享堆[]上分配内存）、读取系统设置、向系统输出日志等，这部分内容由内核核心部分完成并可以被隔离域调用。

我们系统设计的目标是，每个隔离域内出现的任何问题都不会影响到系统的其他部分，从而保证系统的健壮性。为了实现这一目标，对于每个隔离域，我们要求它们满足如下约束：

1. 故障隔离：一个隔离域程序出现无法恢复的故障时，内核不会停止运行，而是可以对此情况进行处理。
2. 内存隔离：一个隔离域内不能有指针指向其他隔离域中的对象。这能让系统回收任何一个隔离域时都无需担心其他隔离域受影响。
3. 动态加载：在系统运行时，对于崩溃的隔离域需要进行重启或更换。这需要系统有在运行时加载并使用一个隔离域的能力。

为了满足以上约束，我们设计了对于接口定义和内存使用的一些机制。

=== 交互接口

交互接口是每个隔离域与域外任何部分（包括内核和其他隔离域）进行通信时必须要使用的交互方式。在一个普通的操作系统中，各部分之间的交互是通过函数调用实现的。即被依赖的部分实现一个函数，内部完成所需功能，并且把函数的入口暴露出来，允许其他部分在代码中调用这个函数，从而完成功能。这一点在Alien中也是一样的。但是由于Alien为每个隔离域额外规定了安全约束，因此我们在进行域和其他部分之间的交互时，不能进行任何可能使安全约束遭到破坏的函数调用。

从具体的安全约束出发，对交互接口的规定为了满足内存隔离约束，需要在跨越域边界进行函数调用时，传递的参数和返回值只含有实现了`Copy` `trait`的类型（这使得该参数的数据可以直接通过逐字节拷贝来复制，而不影响其内容的有效性）或存在于共享堆上。任何存在于某一个域私有堆上的数据都不能通过函数调用的参数或返回值方式穿越域边界。通过这种方式，我们构造出了能够满足内存隔离的接口要求。

同时为了满足故障隔离，接口的返回值要做好收到错误的准备。我们要求所有的返回值都必须被放置于定义好的类型`RpcResult<T>`中。因此在域崩溃而无法正常返回所需值的时候，调用者可以收到一个错误而不是跟着一起崩溃。这使得隔离域的交互接口同样满足了故障隔离要求。

=== 内存隔离

不同部分所使用的内存相互暴露经常带来严重的安全问题[]。在现代操作系统中，一种常见的保护内存方式是使用虚拟地址空间，当一个用户程序尝试访问不属于它的地址时，操作系统或硬件会检测到这个非法操作并产生错误[]。而在Alien中不仅对于用户程序进行了内存隔离，对于内核的部分组成模块也进行了隔离域化，为其带来了内存隔离特性。

每个隔离域都会拥有一个单独的堆作为数据存放位置，它被叫做私有堆。同时，存在一个所有隔离域都可能访问的堆，称为公有堆。任何隔离域都不被允许访问其他隔离域的私有堆，任何可能产生这一后果的行为（如在域交互接口中传递指针或引用、从地址直接构建出指针）都会被编译器拒绝。借由这点，我们的操作系统确保了各个隔离域之间堆内存的独立性。此举带来的好处是，我们在任何时候都可以安全的释放一个隔离域所拥有的所有内存，因为没有该隔离域外的指向此处的指针存在，因此把私有堆释放不会带来任何垂悬指针问题。这为域崩溃后的回收和重载提供了基础。

对于有大量数据需要在域之间进行传递的情况，系统提供了一个共享堆用于处理。借助传递指向共享堆上数据的指针，可以实现大量数据的0拷贝传递。共享堆上的数据也必须满足对于故障隔离的约束，即当某个域崩溃时，它所遗留下的对象不会对其他任何域产生影响。因此，每个共享堆上的对象都必须满足如下原则：（1）它在任何时刻拥有且只拥有一个所有权域。（2）它不能存在任何形式的可变引用，只能有不可变引用和所有权转移发生。

系统提供了一种独特的类型`RRef<T>`。它实际上是共享堆中的物体在代码中的对应，该类型相关的API也是隔离域被允许使用共享堆的唯一方式。当隔离域尝试构建一个`RRef<T>`对象时，系统会在共享堆中分配一块内存，构建出一个`T`对象，并记录该对象现在属于哪个隔离域。在跨域进行调用，使用`RRef<T>`作为参数或者返回值时，系统会自动的更新该对象的所有权域。当一个域崩溃时，检查它拥有的所有共享堆对象，这些对象此时所有权都在崩溃的域中，并且其他域对它不可能有可变引用，只有不可变引用。因此该对象能够在所有对于它的引用都结束后安全的被释放。如果崩溃的域正在尝试对其进行修改，那么由于编译器的限制，其他域不可能拥有对它的任何引用。而如果其他的域对其有不可变引用，那么该对象的值不会改变，将会一直维持直到所有的引用消失。这整个过程中对象的值都与此时第一个不可变引用出现时对象的值相一致，满足其他域对其的读取要求。

=== 故障隔离

故障隔离的主要特点是，可以在某一个隔离域崩溃时，正常地向内核其他部分返回一个`Error`类型的错误，而不是让系统出现无法运行的严重错误。我们随后可以对于该域进行重载等操作。

一个正常程序崩溃可能会有很多原因，但是一个共同点是它将被视为无法靠其自己的逻辑解决此错误。在这种情况下，rust程序在收到崩溃的通知后，会跳转到一个特殊的函数入口，被称为`panic_handle()`[]。通常情况下，这个函数会打印出崩溃时的调用栈和寄存器信息，供开发人员分析崩溃发生的原因。在no_std环境中，这个函数需要程序员自己实现，而Alien对于每个隔离域，都会自动生成一个错误处理函数，它干的事除了打印相关信息之外，还会让处理器跳转回到这次对于隔离域的调用之前的状态，这是通过记录即将进行调用时的寄存器信息并将其在错误处理函数中恢复而实现的。在恢复之后，本来处理器将要执行的程序应该是隔离域内的该函数，但是由于隔离域已崩溃，我们让处理器转而执行一个专门返回错误的函数。这样就防止了隔离域的崩溃带来的整体系统崩溃，而能让系统继续运行。

因此调用者可能收到的回复除了正常时候的返回值以外，还可能是一个错误。这通过Rust语言提供的`Result`类型来实现。`Result`是rust预定义的一种`enum`类型，可以存放正常执行代码后得到的结果或者代码故障产生的错误。通过强制所有域接口都返回一个经过我们包装过的`RpcResult<T>`类型，可以确保隔离域在崩溃时调用者收到合适的返回值，做到故障隔离。

当一个域崩溃后，可能还有一些部分的代码存有该域对象，并且想要使用其完成一些工作。此时由于该对象实际已经不存在并且被回收了，因此对其的任何调用都将是错误的。为了避免这种情况，系统需要在该域被调用的时候进行一次判断，验证其是否正常存在。如果不存在，则得益于上文提到的返回值约束，可以直接向调用者返回一个错误表明域已经崩溃。否则，再把调用请求传递给域让其完成功能。这部分实现我们使用域之外的一层代理来实现。该代理内会引用开发者实际编写的域，任何尝试对域的调用都会通过代理来交互。让代理和原隔离域之间感受不到差异的透明度主要依靠Rust的`trait`系统实现。任何域提供的函数接口都是以一个`trait`的形式展现，而只要代理实现了这个`trait`，那么对于调用者来说它的行为就与原隔离域没有区别。调用者不会关注`trait`之下是什么结构如何实现的。同时，代理也需要接受域执行一个函数调用的中途可能发生的崩溃并准备好一个返回错误的函数供`panic_handle`处理时使用，向调用者返回错误。

=== 动态加载

在某个隔离域发生崩溃之后，我们不仅希望系统能够继续运行，还希望能在调用者没有感知的情况下对崩溃的域进行恢复。这就要求系统具有动态卸载、加载隔离域的能力，同时还需要能够保存某次调用时传入的参数。这样在收到域崩溃的信息时，系统不仅可以选择直接向调用者返回一个错误，还可以选择重新加载一次崩溃的域或者使用其他功能相同的域对它进行替换，然后再执行之前引起崩溃的那次函数调用，向调用者返回正确的结果。

为了达到这一目标，我们使用了一个影子域，它的作用是保存调用时传入的参数并尝试恢复该崩溃的域。由于我们传入的参数的所有权在到达代理域的时候就已经被转移了，因此这一工作需要在外部影子处来完成。通过新的这一层封装，可以实现隔离域的透明故障恢复，同时也可以支持了用户在运行时对某个隔离域进行切换。

为了使各个隔离域能够动态加载和切换，对其他隔离域的依赖不能通过简单的传入一个该域的对象来完成。这是因为当想要替换该作为依赖的域时，使用它的域没有高效的方法得知这一消息并进行替换，因此Alien使用另一种方案，以使使用者不直接持有被依赖域的对象。我们使用一个BTreeMap数据结构存放所有域对象和它的标识。当某个域想要使用另一个域的功能时，只需使用系统给隔离提供的系统调用之一，从标识符从BTreeMap处获取当前系统中使用的该功能域的具体对象即可。这使得系统的灵活性增加，能够支持动态切换隔离域。