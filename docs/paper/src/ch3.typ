= 驱动实现

== VirtIO驱动

VirtIO设备 @virtio 是一种专门为虚拟环境设计的虚拟设备。Alien现阶段在qemu模拟器中运行，因此适配了一些qemu提供的VirtIO设备。包括网卡、输入设备（鼠标、键盘、触摸板等）、块设备（硬盘等）、显示设备、控制台设备。

=== 块设备

块设备是一种用于持久储存数据的IO设备，包括硬盘、SD卡、U盘等。这种设备提供的最小读写单位是块，因此被称为块设备。对块设备可以进行的操作共有8种。每种操作都需要在描述符所指向的地址处放置一个Request结构。其中描述了操作的类型、目标块标号和数据存放缓冲区。注意这个结构可以被分开放置于多个描述符指向的地址中。在实际使用中，需要操作的元数据（操作类型、块标号）被放在首个描述符指向的区域中，并把读写操作所需的缓冲区放置在第二个描述符指向的区域中。设备在完成操作后会向驱动返回一个状态值，它将被存放在缓冲区之后的第三个（非读写操作则是第二个）描述符指向的区域中。

块设备的特点是对它的操作是由系统发出、设备接受的。这与VirtIO所设计的操作通信模式一致，因此较容易实现。

驱动提供了阻塞式和非阻塞式的接口，使用者可以任选一种使用。非阻塞式是基础的操作方式，也是VirtIO设备运行的模式。驱动在发出操作请求之后，可以不时进行查询操作是否完成。如果完成，则接受操作的结果。此外，如果中断特性被协商开启，那么设备在完成操作之后也会发出一个中断来通知系统。

=== 输入设备

输入设备是用于接受用户外部输入的设备，包括鼠标、键盘、触摸板等。输入设备的操作类型非常简单，只有一种，就是驱动从设备处接受一个输入事件。这个事件将会含有一些属性，如输入类型（触发了哪个按键），鼠标移动的距离，等。通信方式是驱动向设备发出一个请求，而当输入设备接受到一个新的用户输入时，就把输入写入到请求中的储存区域，然后返回给驱动。

输入设备与之后的网卡，这两个设备与块设备之间有一点不同，就是它们需要处理的事件会包含从设备处发出而系统接受的类型。这种类型与VirtIO设备的操作通信模式相异，因此需要一些额外的处理。被选中的解决方案是，从驱动初始化的时候开始，就保持可用环（即驱动向设备发出的请求）始终为满。因此，每当设备接受到一个输入时，总是有可用的请求用于存放输入并返回给驱动（可用请求总数为队列大小）。而系统会定期轮询驱动查询有无新的输入。此时驱动会把一个设备已经完成并返回的操作接受，取出其中的输入传给系统，并继续向可用环中插入新的请求。

=== 网卡

网卡是用于通过网络通信（即发送与接受数据包）的设备。驱动在这个过程中要做的事情主要有两件，即收和发数据包。在发送数据包时，驱动从系统处获取想要发送的一个数据包，在其前方加入VirtIO网络包的header，并将其传递给设备处理。在接受数据包时，驱动从设备处获取一个收到的数据包，剥离其开头的VirtIO网络包header，并把内部的内容返回给系统。

网卡与输入设备虽然都有与VirtIO操作通信模式相异的事件，但它们之间还有不同之处，这是因为输入设备需要接受的是可以直接进行逐字节拷贝（即实现了`Copy` `trait`）的基本类型数据，其大小极小（仅64位）使得拷贝过程不会影响性能。但是网卡所接受的内容是一整个数据包，其大小可能达到上千字节。如果逐字节拷贝这个数据，那么对性能的影响将会是不可接受的。因此可行的方案是直接保持数据在内存中的存放位置不懂，仅传递指针。在一些情况下，使用者可能想要自行决定网络收发的数据包需要放在什么地方（如Alien中数据包需要跨域进行传递，因此需要被放置在共享堆上）。另外的情况下使用者可能想要开箱即用而不关心数据包实际上存放在了哪里。因此向使用者提供了两种不同的驱动：`VirtIONet`和`VirtIONetRaw`。从名称上可以看出，后者允许使用者自行为数据包收发分配内存空间，并只需向驱动提供数据包的地址即可；前者则在基础驱动之上进行了更多的封装，提供了直接传入数据包进行发送，接受数据包的功能。当然这会带来一定的性能损失，对性能有追求的使用者应该使用基础的驱动。

== Uart16550驱动

这是一个物理存在的串口设备。与VirtIO系列的设备不同。因此它的驱动也和VirtIO设备的驱动分开成了两份代码。串口设备用于在多个设备间进行字节粒度的数据传输。它的通信模式也更加简单：往其某个寄存器中写入数据即是发送，而从某个寄存器中读取数据即是接受。

与VirtIO设备相同，对寄存器的操作也被归纳成了一个`trait`，提供按字节对一段内存进行读写的能力。该段内存被映射到设备寄存器上。

