# 测试

通常认为使用底层的C语言的一个优势是其效率更高。而Rust的零成本抽象为其带来了与C/C++类似的性能。通过对有较高性能需求的块设备驱动的速度测试，可以展现出使用安全代码编写的设备驱动与不安全代码相比性能变化如何。

以下的测试所处环境是：
中央处理器：13th Gen Intel(R) Core(TM) i9-13900HX
操作系统：Windows Subsystem for Linux (WSL) 2 Ubuntu 20.04
虚拟机软件：qemu 7.0.0

## 4.1 块设备

### 4.1.1 吞吐率

对块设备的测试采用顺序读写的方式进行。使用的设备大小为20MB。该设备是一个由`dd`命令所创建的文件，每次写入1MB的源于`/dev/zero`的数据，总共执行数量为20次。随后可以在qemu的运行命令中将该20MB的文件作为一个存储设备传递给虚拟机中。测试中分别使用本项目的安全Rust实现的驱动和用于对比的使用了不安全代码的设备驱动对其进行总共200次全盘读写，并记录每次的时间和速度。最后以此计算出两种不同驱动的平均速度和方差。写入时所使用的数据全部为0xFF，而对于读取时的数据未进行任何初始化。200次全盘读写会分为20次进行，每次会读写十倍于整个设备的数据量。这些操作按照块编号由低到高的顺序被执行，并在超出最大空间之后回到0号块继续进行循环。每次读写在开始前后都会读取riscv架构中用于计时的寄存器，将之相减后能够获知该读写操作总共所花费的时钟周期。由于qemu中riscv机器的cpu频率已知，因此通过计算可以获知该计时时长对应多少现实时间。块的大小通过驱动的查询容量功能获取，而非硬编码在测试程序中，可以应对不同大小的设备的测试需要。计时的区域不包括查询块设备大小所耗费的时间。但是会计入循环语句的时间与对驱动程序提供的功能进行函数调用的时间。最后通过计算每次总读写的数据量与耗时之商，可以获知该次操作的实际吞吐量。驱动所提供的查询容量所返回的单位是块。而一块在VirtIO块设备的规定中大小为512字节，因此该返回值与一块的存储大小相乘就是整个设备的容量。为了保证测试结果的精确性，在进行测试时，不对测试机器进行任何其他操作以避免有程序与qemu抢占CPU从而导致测试结果不准确。为提高计算精度，所有数值都被转化为64位浮点数进行运算。每次单次测试出来的结果将会被存入一个数组中，此操作不会被计入所耗费时间。在所有次测试都结束后，对于所获得的每次速度数组，可以进行求平均与求方差的操作，以此减小测例结果中的误差，增大可信度。方差被用于说明设备驱动的运行速度稳定性。

测试所得的原始数据可以在此查看，测试所用代码分别在github代码仓库下的`svdrivers/qemu`和`virtio-drivers/example/riscv`文件夹中。测试的结果如下图：

|操作类型|安全代码|不安全代码|
|-------|-------|--------|
|读     |19.86MB/s 0.0274|19.87MB/s 0.086|
|写     |18.035MB/s 0.129|17.401MB/s 0.038|

从如上数据中可以看出，使用安全代码实现的VirtIO块设备驱动相比于不安全的设备驱动，在顺序读取操作上速度相差无几，而在顺序写入时，其速度甚至比不安全的实现快了3.6%。

写操作普遍比读操作缓慢，但是差距并不大，只有约2MB/s的差距。读和写操作都接近一个上限，即20MB/s。我们认为这个速度是在虚拟环境中使用单处理器对块设备进行读写的速度上限。安全驱动和不安全驱动均接近这个上限，表明在现有应用场景中驱动的性能并没有成为操作的瓶颈。

这些数据说明了在块设备驱动这方面，使用不安全代码并没有显著的速度优势。因此可以放心的使用安全的设备驱动，而不需要担心其可能对性能造成的影响。
