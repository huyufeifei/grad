# 开发帮助

对于域的开发（主要是驱动）过程中进行的操作，进行总结。

## 系统结构（暂定）

先了解系统结构有助于快速准确的进行开发。  
域代码的主体放在`Alien/domains/`下，特别的，驱动放在`Alien/domains/drivers/`下。  
在目标目录下，每一个域都会作为一个独立的crate存在。这个crate中就是域代码的存放位置。  
在开发过程中，可能会用到系统中提供的别的功能，此时直接在`Cargo.toml`的`dependencies`中进行引用即可。  

### generated crate

除了主体包之外，我们需要编写一个额外的包，位于`Alien/domains/generated`下。命名则是域crate的名字前面加上一个`g`  
这个包为我们的域和系统之间进行对接工作，如初始化、提供错误隔离功能等。它的任务包括（目前）：  
1. 为域的系统调用初始化。
2. 获取属于自己的堆。（系统中每个域会有一个独立的堆空间）
3. 初始化域的日志系统。
4. 把域标为激活。
5. 调用域的主函数，返回代表域的一个对象。
6. 提供no_std环境下编译所需的`panic_handle`函数。这个函数会在域错误时被调用，输出错误信息，把域标为崩溃，并让内核尝试恢复（重新加载）此域。

因为每个域的此crate内容代码高度相似，后期可以考虑使用宏自动化生成这一crate。但是在现阶段，需要开发者手动编写。

### interface 接口

每个域都在内核中有至少一个接口用来描述功能。它位于 `Alien/domain-tools/interface` crate中。  
如果开发的域在其中未定义，则需要添加。在其中新建一个文件（mod），在其中编写域的接口（trait），并在`lib.rs`中公开使用即可。  
我们所编写的域就是一个实现了该trait的结构体。  

### proxy 调用代理

每个域在内核中会有一个代理结构体用来包装对域的调用。它位于`Alien/base/proxy`这个crate中。  
类似interface，在其中新建一个文件（mod），在其中编写域的代理（struct），并在`lib.rs`中公开使用即可。  
代理结构要进行的工作是：  

1. 记录域编号
2. 在内核调用域的时候，先检查域是激活还是崩溃。（通过调用域本身的`is_active`实现。这个函数是在`interface/lib.rs` 中的 `Basic` trait 默认实现的）  
   如果域是激活，则向它发出真正的调用。

代理结构体也需要实现interface中所定义的域trait，内核中实际使用的是代理，域被放在代理内。

### 启用与编译

修改`Alien/Cargo.toml`，在其中把新加入的两个crate（域本身和generated）加入members列表。这使域能够被正常编译。  
修改`Alien/Makefile`，在`domains = `一行加入generated域的名称，这会使编译脚本包含新编写的域。  
在`Alien/`下执行`make domains`会编译所有的域。  
如果编译成功，则会在`Alien/build`下生成一个`gxxxx_domain.bin`的二进制文件。它目前会被内核硬编码，并加载成为运行的域。

### 添加设备与加载

域的加载在`Alien/kernel/src/domain` mod中。在其中把先前生成的二进制文件硬编码成字符数组。  
使用`DomainLoader`提供的`new`函数加载这个字符数组，再执行`load`函数，就可以解析出我们的generated包的入口函数。  
之后传入分配的域id进行调用，就可以获得域对象了。它外面会包裹一层proxy对象。这个过程会写在一个加载函数中。  

如果是驱动域，则需要在qemu的命令中添加对应设备，让qemu模拟出这个设备来。  
这需要修改`Alien/Makefile`中执行qemuu时使用的参数，通常是加入`-device xxxxxx`  
之后，这个设备就会被内核检测到，随后内核会在上文提到的mod中的`init_device()`尝试加载设备对应的域。  
在其中`match name {}`语句中添加设备名和对应的你的驱动的初始化函数即可。  

## 域实现

此处指域的主要crate实现。  
我们所编写的域就是一个实现了interface中的trait的结构体。  

### 不安全操作

驱动开发中的读写寄存器等操作是难以避免并且不安全的。  
对此的解决方法是抽象出所需的不安全功能并写成trait，随后内核提供实现了这些trait的结构让域使用。  
在目前已安全化的串口驱动`Uart16550`中，就使用了这样的一个trait `Uart16550IO`。  
它需要内核为域提供一段内存空间的读写功能。内核为了保证安全，在读写前会对地址进行检查。如果越界则会拒绝操作。  
如果内核想使用这个域，则先要编写一个实现了`Uart16550IO`的结构，随后在`Uart16550`的构造函数中传入该结构即可。

### 包装

还未安全化完成的域暂时使用现有的实现，如rcore-os/virtio-drivers。  
我们把这些第三方驱动包装在一个全局静态对象中，并在域的函数实现中调用这个对象。  
这些域之后将会被逐渐安全化。  










